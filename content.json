{"meta":{"title":"OldSecond's Blog","subtitle":"","description":"","author":"OldSecond","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-10-19T16:23:50.000Z","updated":"2021-10-19T16:23:50.635Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"原型（prototype）","slug":"原型","date":"2021-12-03T16:00:00.000Z","updated":"2021-12-03T20:13:36.974Z","comments":true,"path":"2021/12/04/原型/","link":"","permalink":"http://example.com/2021/12/04/%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"在声明了一个函数之后，会自动按照一定的规则创建一个对象，这个对象就叫做原型对象。这个函数中会有一个属性prototype，这个属性指向的就是这个函数对应的原型对象；原型对象中有一个属性constructor，这个属性指向的是这个函数。 使用构造函数创建对象1234function students() &#123;&#125;var stu = new students(); 此时，stu就是那个构造函数students创建出来的对象，这个stu对象中是没有prototype属性的，prototype属性只在构造函数students中有。 构造函数students中有prototype属性，指向的是students对应的原型对象；而stu是构造函数students创建出来的对象，不存在prototype属性，所以在调用prototype的时候的结果是undefined，但stu有一个proto属性，stu调用这个属性可以直接访问到构造函数students的原型对象（也就是说，stu的proto属性指向的是构造函数的原型对象） 从上面可以看到，创建stu对象虽然使用的是students构造函数，但是对象创建出来之后，这个stu对象其实已经与students构造函数没有任何关系了，stu对象的proto属性指向的是students构造函数的原型对象。 如果使用new students()创建多个对象stu1、stu2、stu3，则多个对象都会同时指向students构造函数的原型对象。 12console.log(stu1.__proto__ == stu2.__proto__);//输出 true 我们可以手动给这个原型对象添加属性和方法，那么stu1,stu2,stu3…这些对象就会共享这些在原型中添加的属性和方法。 12345students.prototype.name=&quot;张三&quot;;console.log(stu1.__proto__.name)//输出 张三console.log(stu2.__proto__.name)//输出 张三 如果我们访问stu中的一个属性name，如果在stu对象中找到，则直接返回。如果stu对象中没有找到，则直接去stu对象的proto属性指向的原型对象中查找，如果查找到则返回。(如果原型中也没有找到，则继续向上找原型的原型—原型链)。 如果通过p1对象添加了一个属性name，则p1对象来说就屏蔽了原型中的属性name。 换句话说：在p1中就没有办法访问到原型的属性name了。通过p1对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 p1.name = “李四”; 并不是修改了原型中的值，而是在p1对象中给添加了一个属性name。 123456students.prototype.name = &quot;张三&quot;;stu2.name = &quot;李四&quot;;console.log(stu1.name)//输出 张三console.log(stu2.name)//输出 李四 与原型有关的几个方法prototype属性存在于构造函数中，指向了这个构造函数的原型对象。 constructor属性存在于原型对象中，指向了构造函数 1234function students() &#123;&#125;;console.log(students.prototype.constructor == students)//输出 true __proto__ 属性用构造方法创建一个新的对象之后，这个对象中默认会有一个属性__proto__, 这个属性就指向构造方法的原型对象。","categories":[],"tags":[],"author":"OldSecond"},{"title":"新生研讨课作业2","slug":"新生研讨课作业2","date":"2021-11-30T16:00:00.000Z","updated":"2021-11-30T18:14:20.704Z","comments":true,"path":"2021/12/01/新生研讨课作业2/","link":"","permalink":"http://example.com/2021/12/01/%E6%96%B0%E7%94%9F%E7%A0%94%E8%AE%A8%E8%AF%BE%E4%BD%9C%E4%B8%9A2/","excerpt":"","text":"用流程图表示如下式子的计算过程 S=1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+\\frac{1}{9}-\\frac{1}{11}......+\\frac{1}{197}-\\frac{1}{199}","categories":[],"tags":[],"author":"OldSecond"},{"title":"新生研讨课作业","slug":"新生研讨课作业1","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-01T15:21:46.705Z","comments":true,"path":"2021/10/31/新生研讨课作业1/","link":"","permalink":"http://example.com/2021/10/31/%E6%96%B0%E7%94%9F%E7%A0%94%E8%AE%A8%E8%AF%BE%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"互联网企业如何全面做到“遵纪守法”？近日，国家网信办公告称，网络安全审查办公室按照《网络安全审查办法》，对“运满满”“货车帮”“BOSS直聘”实施网络安全审查。这也是继滴滴出行后，最新被列入审查名单的互联网企业。 从网信办的公告中可以看出，此次被列入审查名单的互联网企业，无不例外是因为“网络安全”问题，作为互联网企业，在面对日渐完善的法律法规监管之下，又应该如何做到“遵纪守法”呢？ 对于中国的互联网企业而言，运用大数据来产生价值早已经是最常见的商业模式，甚至已经成为了互联网企业眼中的“技术壁垒”。此前百度公司创始人、董事长兼CEO李彦宏在谈到大数据如何发挥应有价值时就表示，企业应思考如何利用大数据，要让大数据产生应有的价值。 在“挖掘数据价值”的“共识”下，中国互联网企业一拥而上地利用从社会和用户当中获取的数据，快速推进了诸如人工智能、自动驾驶等领域的发展，也让部分企业站在数据资源的优势上快速发展，成为互联网行业中的新巨头。 从某种程度上而言，目前互联网行业之间的竞争，已经成为数据之间的竞争，谁获得更多更有价值的数据，就更有可能在互联网行业中脱颖而出。但是搜集了大量的数据应该如何用？怎样用才是合法合规？这些问题对于所有的中国互联网企业而言都是“新问题”。","categories":[],"tags":[],"author":"OldSecond"},{"title":"块级格式化上下文（Block Formatting Context，BFC）","slug":"块级格式化上下文","date":"2021-10-22T16:00:00.000Z","updated":"2021-11-01T15:47:22.581Z","comments":true,"path":"2021/10/23/块级格式化上下文/","link":"","permalink":"http://example.com/2021/10/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"一、什么是BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，BFC内部的元素布局与外部互不影响 二、形成BFC的条件根元素（&lt;html&gt;）浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group、inline-table)overflow 计算值(Computed)不为 visible 的块元素display 值为 flow-root 的元素contain 值为 layout、content 或 paint 的元素弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）网格元素（display 为 grid 或 inline-grid 元素的直接子元素）多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中 三、BFC布局规则1.内部的Box会在垂直方向，一个接一个地放置。2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。4.BFC的区域不会与float的元素重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算 四、BFC应用实例1. 自适应两栏布局1234567891011121314body &#123; width: 300px; position: relative;&#125;.aside &#123; width: 100px; height: 150px; float: left; background: #f66;&#125;.main &#123; height: 200px; background: #fcc;&#125; 1234&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第三条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float的元素重叠 可以通过通过使main生成BFC， 来实现自适应两栏布局。123.main &#123; overflow: hidden;&#125;当main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 2. 清除内部浮动1234567891011.father &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width: 100px; height: 100px; float: left;&#125; 123456&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发father生成BFC，那么father在计算高度时，father内部的浮动元素child也会参与计算。 123.father &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠12345678p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 1234&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 1234567891011.wrap &#123; overflow: hidden;&#125;p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 123456&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 总结以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。","categories":[],"tags":[],"author":"OldSecond"}],"categories":[],"tags":[]}