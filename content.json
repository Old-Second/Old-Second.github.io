{"meta":{"title":"OldSecond's Blog","subtitle":"","description":"","author":"OldSecond","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-10-19T16:23:50.000Z","updated":"2021-10-19T16:23:50.635Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"新生研讨课作业2","slug":"新生研讨课作业2","date":"2021-11-30T16:00:00.000Z","updated":"2021-11-30T17:33:37.960Z","comments":true,"path":"2021/12/01/新生研讨课作业2/","link":"","permalink":"http://example.com/2021/12/01/%E6%96%B0%E7%94%9F%E7%A0%94%E8%AE%A8%E8%AF%BE%E4%BD%9C%E4%B8%9A2/","excerpt":"","text":"新生研讨课作业2用流程图表示如下式子的计算过程$$S=1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+\\frac{1}{9}-\\frac{1}{11}……+\\frac{1}{197}-\\frac{1}{199}$$ ![未命名文件 (1)](D:\\Files\\下载\\未命名文件 (1).png)","categories":[],"tags":[],"author":"OldSecond"},{"title":"新生研讨课作业","slug":"新生研讨课作业1","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-01T15:21:46.705Z","comments":true,"path":"2021/10/31/新生研讨课作业1/","link":"","permalink":"http://example.com/2021/10/31/%E6%96%B0%E7%94%9F%E7%A0%94%E8%AE%A8%E8%AF%BE%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"互联网企业如何全面做到“遵纪守法”？近日，国家网信办公告称，网络安全审查办公室按照《网络安全审查办法》，对“运满满”“货车帮”“BOSS直聘”实施网络安全审查。这也是继滴滴出行后，最新被列入审查名单的互联网企业。 从网信办的公告中可以看出，此次被列入审查名单的互联网企业，无不例外是因为“网络安全”问题，作为互联网企业，在面对日渐完善的法律法规监管之下，又应该如何做到“遵纪守法”呢？ 对于中国的互联网企业而言，运用大数据来产生价值早已经是最常见的商业模式，甚至已经成为了互联网企业眼中的“技术壁垒”。此前百度公司创始人、董事长兼CEO李彦宏在谈到大数据如何发挥应有价值时就表示，企业应思考如何利用大数据，要让大数据产生应有的价值。 在“挖掘数据价值”的“共识”下，中国互联网企业一拥而上地利用从社会和用户当中获取的数据，快速推进了诸如人工智能、自动驾驶等领域的发展，也让部分企业站在数据资源的优势上快速发展，成为互联网行业中的新巨头。 从某种程度上而言，目前互联网行业之间的竞争，已经成为数据之间的竞争，谁获得更多更有价值的数据，就更有可能在互联网行业中脱颖而出。但是搜集了大量的数据应该如何用？怎样用才是合法合规？这些问题对于所有的中国互联网企业而言都是“新问题”。","categories":[],"tags":[],"author":"OldSecond"},{"title":"块级格式化上下文（Block Formatting Context，BFC）","slug":"块级格式化上下文","date":"2021-10-22T16:00:00.000Z","updated":"2021-11-01T15:47:22.581Z","comments":true,"path":"2021/10/23/块级格式化上下文/","link":"","permalink":"http://example.com/2021/10/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"一、什么是BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，BFC内部的元素布局与外部互不影响 二、形成BFC的条件根元素（&lt;html&gt;）浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group、inline-table)overflow 计算值(Computed)不为 visible 的块元素display 值为 flow-root 的元素contain 值为 layout、content 或 paint 的元素弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）网格元素（display 为 grid 或 inline-grid 元素的直接子元素）多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中 三、BFC布局规则1.内部的Box会在垂直方向，一个接一个地放置。2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。4.BFC的区域不会与float的元素重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算 四、BFC应用实例1. 自适应两栏布局1234567891011121314body &#123; width: 300px; position: relative;&#125;.aside &#123; width: 100px; height: 150px; float: left; background: #f66;&#125;.main &#123; height: 200px; background: #fcc;&#125; 1234&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第三条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float的元素重叠 可以通过通过使main生成BFC， 来实现自适应两栏布局。 123.main &#123; overflow: hidden;&#125; 当main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 2. 清除内部浮动1234567891011.father &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width: 100px; height: 100px; float: left;&#125; 123456&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发father生成BFC，那么father在计算高度时，father内部的浮动元素child也会参与计算。 123.father &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠12345678p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 1234&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 1234567891011.wrap &#123; overflow: hidden;&#125;p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 123456&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 总结以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。","categories":[],"tags":[],"author":"OldSecond"},{"title":"","slug":"原型","date":"1970-01-01T00:00:00.000Z","updated":"2021-11-28T17:03:28.140Z","comments":true,"path":"1970/01/01/原型/","link":"","permalink":"http://example.com/1970/01/01/%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Eloquent JavaScript","date":"1970-01-01T00:00:00.000Z","updated":"2021-11-27T19:59:57.222Z","comments":true,"path":"1970/01/01/Eloquent JavaScript/","link":"","permalink":"http://example.com/1970/01/01/Eloquent%20JavaScript/","excerpt":"","text":"Eloquent JavaScript第1章 值、类型和运算符第2章 程序结构第3章 函数3.1 定义一个函数使用以关键字function开头的表达式创建函数。函数有一组参数和一个函数体，其中包含调用函数时要执行的语句。以这种方式创建的函数的函数体必须用大括号括起来，即使它只包含一个语句。 函数的返回值可以有，可以没有，没有则默认返回 undefined。函数可以制造副作用，也可以返回值 3.2 绑定和作用域全局绑定：对于在任何函数或块之外定义的绑定，作用域是整个程序可以在任何地方引用此类绑定。 局部绑定：为函数参数创建的绑定或在函数内声明的绑定只能在此函数中引用。 let和const声明的绑定是在声明它们的块中局部可见的，如果在循环中创建上面两种绑定，循环之前和之后代码都不能“看到”它。var创建的绑定在出现它们的整个函数中是可见的，如果它们不在一个函数中，则它们在全局作用域中可见。 每个作用域可以”查看“包围它的作用域，因此x在下面示例中的块内部是可见的。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); //→60&#125;//y在此处不可见console.log(x + z);//→40 异常情况：多个绑定具有相同的名称，这时代码只能看到最里面的一个。如下示例，在halve函数内部的代码引用n时，它只能看到自己n，而不是全局的n。 123456789const halve = function(n) &#123; return n / 2;&#125;;let n = 10;console.log(halve(100));//→50console.log(n);//→10 js不仅区分全局绑定和局部绑定，还可以在其他块和函数内创建块和函数，从而产生多个度的局部。 词法作用域：块内可见的绑定集由程序文本中此块的位置确定。每个局部作用域可以查看包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 3.3 作为值的函数函数值能执行其他值能执行的所有操作，可以在任意表达式找那个使用它，而不仅仅是调用它。可以将函数值存储在新绑定中，将其作为参数传递给函数。 保存函数的绑定仍然是常规绑定，如果不是常量，就可以赋予一个新值 3.4 声明表示法123function square(x) &#123; return x * x;&#125; 这是一个函数声明，并且在函数后不需要分号。 12345console.log(&quot;The future says:&quot;, future());function future() &#123; return &quot;You&#x27;ll never have flying cars&quot;;&#125; 即使函数是在使用它的代码下定义的，也可以正常工作。函数声明不是常规的从上到下控制流程一部分。它们在概念上被移动到它们的作用域的顶部，可以由此作用域中的所有代码使用。 3.5 箭头函数函数的第三种表示法使用(=&gt;)代替function关键字 1234567const power = (base, exponent) =&gt; &#123; let result = 1; for (let count = 0; count &lt; exponent; count++) &#123; result *= base; &#125; return result;&#125;; 如果只有一个参数名称，则可以省略参数列表周围的括号。如果函数体是单个表达式而不是大括号中的块，则该函数将返回这个表达式。示例如下： 12const square1 = (x) =&gt; &#123; return x * x; &#125;;const square2 = x =&gt; x * x; 当箭头函数没有参数时，其参数列表只是一组空括号。 123const horn = () =&gt; &#123; console.log(&quot;Toot&quot;);&#125;; 3.6 调用栈在函数返回时必须跳回调用它的位置，所有计算机必须记住调用发生的上下文。计算机存储此上下文的位置是调用栈。每次调用函数时，当前上下文都存储在此栈的顶部。当函数返回时，它会从栈中删除顶层上下文冰使用次上下文继续执行 存储此栈需要计算机内存中的空间。当栈变得太大时，计算机将失败并显示“栈空间不足”或“递归过多”等消息。示例如下： 12345678function chicken() &#123; return egg();&#125;function egg() &#123; return chicken();&#125;console.log(chicken() + &quot; came first.&quot;);// → ?? 3.7 可选参数123function square(x) &#123; return x * x; &#125;console.log(square(4, true, &quot;hedgehog&quot;));// → 16 上面只用了一个参数定义了square，但当我们用三个函数调用它时，JavaScript会忽略额外的参数并计算第一个参数的平方。 如果传递太多参数，则会忽略额外的参数，如果传递的参数太少，则缺少的参数将赋值为undefined。 缺点是可能会将错误数量的参数传递给函数。好处是可用于允许使用不同数量的参数调用的函数。例如：用minus函数模仿”-“运算符 123456789function minus(a, b) &#123; if (b === undefined) return -a; else return a - b;&#125;console.log(minus(10));// → -10console.log(minus(10, 5));// → 5 如果在参数后写一个=运算符，后跟一个表达式，那么将在未给出某参数时用此表达式的值替换该参数。例如： 123456789101112function power(base, exponent = 2) &#123; let result = 1; for (let count = 0; count &lt; exponent; count++) &#123; result *= base; &#125; return result;&#125;console.log(power(4));// → 16console.log(power(2, 6));// → 64 3.8 闭包3.8.1 概念引用其周围局部作用域的绑定的一个函数称为一个闭包 有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。 第一，闭包是一个函数，而且存在于另一个函数当中 第二，闭包可以访问到父级函数的变量，且该变量不会销毁 1234567891011function person()&#123; var name = &#x27;有鱼&#x27;; function cat()&#123; console.log(name); &#125; return cat;&#125;var per = person();// per的值就是return后的结果，即cat函数per();// 有鱼 per()就相当于cat()per();// 有鱼 同上，而且变量name没有销毁，一直存在内存中，供函数cat调用per();// 有鱼 3.8.2 原理闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。 例如： 123456var age = 18;function cat()&#123; age++; console.log(age);// cat函数内输出age，该作用域没有，则向外层寻找，结果找到了，输出[19];&#125;cat();//19 如果再次调用，age的值会一直增加。 123cat();//20cat();//21cat();//22 如果其他函数需要用到age的值，那么就会受到影响，且全局变量容易被修改，所以要把变量封装到函数内，让它成为局部变量 12345678910function person()&#123; var age = 18; function cat()&#123; age++; console.log(age); &#125; return cat;&#125;person();// 19person();// 19 若如上例，则每次调用函数，age会重新赋值为18，所以cat的值一直为19，因此做如下调整： 1234var per = person();//per相当于函数catper();// 19 即cat() 这样每次调用不在经过age的初始值，这样就可以一直增加了per();// 20per();// 21 3.8.3 作用作用1：隐藏变量，避免全局污染 作用2：可以读取函数内部的变量 同时闭包使用不当，优点就变成了缺点： 缺点1：导致变量不会被垃圾回收机制回收，造成内存消耗 缺点2：不恰当的使用闭包可能会造成内存泄漏的问题 这里简单说一下，为什么使用闭包时变量不会被垃圾回收机制收销毁呢，这里需要了解一下JS垃圾回收机制； JS规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可节省内存； 使用闭包时，按照作用域链的特点，闭包（函数）外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存销毁。 3.9 递归调用自身的函数称为递归函数 12345678910function power(base, exponent) &#123; if (exponent == 0) &#123; return 1; &#125; else &#123; return base * power(base, exponent - 1); &#125;&#125;console.log(power(2, 3));// → 8 在这个例子中，使用递归的速度比使用循环的速度慢，但递归并不总是替代循环的低效方法，使用递归比使用循环更容易解决一些问题。 题：从1开始，重复加5或乘3，可以生成一个由无数的数字组合成的集合。对于给定的一个数字，找到产生这个数字的一系列加法和乘法。 以下为一个递归的方案： 12345678910111213141516function findSolution(target) &#123; function find(current, history) &#123; if (current == target) &#123; return history; &#125; else if (current &gt; target) &#123; return null; &#125; else &#123; return find(current + 5, `($&#123;history&#125; + 5)`) || find(current * 3, `($&#123;history&#125; * 3)`); &#125; &#125; return find(1, &quot;1&quot;);&#125;console.log(findSolution(24));// → (((1 * 3) + 5) * 3) 3.10 函数的增长方式什么时候应该添加一个函数： ①多次编写类似的代码时，可以把重复的功能提取出来放入一个函数中 ②需要一下尚未编写的功能时并且它应该有自己的函数时，将从命名函数开始，然后编写它的函数体。在实际定义函数之前，可能已经开始编写使用此函数的代码 为函数命名：驼峰命名法 3.11 函数和副作用函数可以粗略分为为了副作用而调用的函数和为了其返回值而调用的函数。 纯函数是一种特定的产生值的函数，它不仅没有副作用，而且不依赖于其他代码的副作用。 3.12 小结创建函数的三种方法： 1234// 定义f以保存函数值const f = function(a) &#123; console.log(a + 2);&#125;; 1234// 将g声明为函数function g(a, b) &#123; return a * b * 3.5;&#125; 12// 箭头函数let h = a =&gt; a % 3; 第4章 数据结构：对象和数组4.1 松鼠人4.2 数据集数组：专门用于存储值序列的数据类型，写法是将一连串的值写在方括号中，值中间使用逗号分隔。 1234567let listOfNumbers = [2, 3, 5, 7, 11];console.log(listOfNumbers[2]);// → 5console.log(listOfNumbers[0]);// → 2console.log(listOfNumbers[2 - 1]);// → 3 获取数组内部元素也用方括号表示，写法是表达式后紧跟一对方括号，并在方括号中填写表达式，将会在左侧表达式里查找方括号中给定的索引所对应 的值，并返回结果。数组的第一个索引是0，而不是1。 4.3 属性如myString.length（获取字符串的长度）和Math.max（取最大值函数）。这是访问某个值的属性的表达式。 几乎所有JavaScript值都具有属性，但null和undefined除外，尝试访问这两种值的属性，则会出现错误。 12null.length;// → TypeError: null has no properties 访问属性的两种主要方法是使用句点和方括号。 value.x和value[x]都访问值上的属性，但不一定是相同的属性。使用句点时，点后面的单词是属性的文字名称。而使用方括号时，将计算括号中的表达式来获取属性名称。点表示法仅适用于其名称看起来像有效绑定名称的情况。例如：数组中的元素存储为数组的属性，使用数字作为属性名称，因此不能用点表示法获取。 4.4 方法字符串和数组对象都包含许多保存函数值的属性。 toUpperCase：将所有字母转化为大写；toLowerCase：将所有字母转化为小写。 push将值添加到数组的末尾，pop删除数组中最后一个值并返回。 4.5 对象类型对象的值是属性的任意集合。创建对象的一种方法是使用大括号作为表达式。大括号内有以逗号分隔的属性列表。每个属性都有一个名称，后跟冒号和值。当属性名不是有效绑定名称或有效数字时，必须用引号括起来。 可以用=为属性表达式赋值，若已存在则替换属性的值，不存在则创建新属性。 delete将从对象中删除命名属性。二元运算符in会告诉你此对象是否具有该名称的属性。将属性设置为undefined时，对象仍然存在此属性；当删除它时，对象将不存在此属性且in将返回false 12345678910let anObject = &#123;left: 1, right: 2&#125;;console.log(anObject.left);// → 1delete anObject.left;console.log(anObject.left);// → undefinedconsole.log(&quot;left&quot; in anObject);// → falseconsole.log(&quot;right&quot; in anObject);// → true 找出对象具有哪些属性，可使用Object.keys函数 12console.log(Object.keys(&#123;x: 0, y: 0, z: 2&#125;));// → [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] Object.assign函数可以从一个对象把所有属性复制到另一个对象。 1234let objectA = &#123;a: 1, b: 2&#125;;Object.assign(objectA, &#123;b: 3, c: 4&#125;);console.log(objectA);// → &#123;a: 1, b: 3, c: 4&#125; 因此，数组只是一种专门用于存储事物序列的对象。 4.6 可变性对象可以通过修改其属性从而使单个对象值在不同的时候具有不同的内容。 同一对象的两次引用与包含两个相同属性的两个不同对象之间存在差异。 123456789101112let journal = [ &#123;events: [&quot;work&quot;, &quot;touched tree&quot;, &quot;pizza&quot;, &quot;running&quot;, &quot;television&quot;], squirrel: false&#125;, &#123;events: [&quot;work&quot;, &quot;ice cream&quot;, &quot;cauliflower&quot;, &quot;lasagna&quot;, &quot;touched tree&quot;, &quot;brushed teeth&quot;], squirrel: false&#125;, &#123;events: [&quot;weekend&quot;, &quot;cycling&quot;, &quot;break&quot;, &quot;peanuts&quot;, &quot;beer&quot;], squirrel: true&#125;, /* and so on... */]; object1和object2绑定抓住了同一个对象，也就是说他们拥有相同的标识。而绑定object3虽然包含和object1相同的属性，但却单独存在。 当使用==比较对象时，会按照标识进行比较：仅当两个对象都是完全相同的值时才会得到true。即使两个不同的对象具有相同的属性，也将返回false。 4.7 松鼠人的日志4.8 计算相关性4.9 数组循环4.10 最终分析4.11 其他数组方法push和pop在数组的末尾添加和删除元素。 123456789let sequence = [1, 2, 3];sequence.push(4);sequence.push(5);console.log(sequence);// → [1, 2, 3, 4, 5]console.log(sequence.pop());// → 5console.log(sequence);// → [1, 2, 3, 4] unshift和shift在数组的开头添加和删除元素。 12345678910let todoList = [];function remember(task) &#123; todoList.push(task);&#125;function getTask() &#123; return todoList.shift();&#125;function rememberUrgently(task) &#123; todoList.unshift(task);&#125; indexOf从开始到结束搜索数组并返回找到给定值的所有，未找到则返回-1。lastIndexOf从末尾而不是从头开始搜索。indexOf和lastIndexOf都有一个可选的第二参数，表示从哪里开始搜索。 1234console.log([1, 2, 3, 2, 1].indexOf(2));// → 1console.log([1, 2, 3, 2, 1].lastIndexOf(2));// → 3 slice接收起始和结束索引并返回一个只包含它们之间元素的数组（前闭后开）。当没有给出结束索引时，slice将获取起始索引之后的所有元素。 1234console.log([0, 1, 2, 3, 4].slice(2, 4));// → [2, 3]console.log([0, 1, 2, 3, 4].slice(2));// → [2, 3, 4] concat方法可用于将数组黏合在一起以创建新数组。如果给concat传递一个不是数组的参数，那么此值将被添加到新数组中。 123456function remove(array, index) &#123; return array.slice(0, index) .concat(array.slice(index + 1));&#125;console.log(remove([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], 2));// → [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;] 4.12 字符串及其属性字符串、数字、布尔类型的值不是对象。 字符串的slice和indexOf属性与同名的数组方法类似。 1234console.log(&quot;coconuts&quot;.slice(4, 7));// → nutconsole.log(&quot;coconut&quot;.indexOf(&quot;u&quot;));// → 5 两者区别之一是字符串的indexOf方法可以搜索包含多个字符的字符串，而同名的数组方法只能查找单个元素。 12console.log(&quot;one two three&quot;.indexOf(&quot;ee&quot;));// → 11 trim方法从字符串的开头和结尾删除空格（空格、换行符、制表符和类似字符）。 12console.log(&quot; okay \\n &quot;.trim());// → okay padStrart将所需的长度和填充字符作为参数。 12console.log(String(6).padStart(3, &quot;0&quot;));// → 006 使用split在每次出现另一个字符串时拆分字符串，并使用join再次把它们拼接起来。 123456let sentence = &quot;Secretarybirds specialize in stomping&quot;;let words = sentence.split(&quot; &quot;);console.log(words);// → [&quot;Secretarybirds&quot;, &quot;specialize&quot;, &quot;in&quot;, &quot;stomping&quot;]console.log(words.join(&quot;. &quot;));// → Secretarybirds. specialize. in. stomping repeat方法重复一个字符串，这会创建一个把原始字符串的多个副本黏合在一起的新字符串。 12console.log(&quot;LA&quot;.repeat(3));// → LALALA length，访问字符串中的单个字符看起来像访问数组元素。 12345let string = &quot;abc&quot;;console.log(string.length);// → 3console.log(string[1]);// → b 4.13 剩余参数要编写能接受任意数量参数的函数，需要在函数的最后一个参数之前放三个点。 123456789function max(...numbers) &#123; let result = -Infinity; for (let number of numbers) &#123; if (number &gt; result) result = number; &#125; return result;&#125;console.log(max(4, 1, 9, -2));// → 9 以...为前缀的最后一个命名参数，将成为一个由剩余参数组成的真数组，其中从0（包括）到numbers.length（排除）的元素由传递给函数的实际参数提供。 调用此类函数时，剩余参数被绑定到包含所有后续参数的数组中。如果剩余参数之前还有其他参数，则那些参数的值不是此数组的一部分。 可使用类似的三点表示法来调用带有参数数组的函数。 123let numbers = [5, 1, 7];console.log(max(...numbers));// → 7 这会将数组的元素作为单独的参数传递。函数调用可以同时包含像这样的数组以及其他参数，如max(9,…numbers,2). 方括号数组表示法同样允许利用三点运算符将另一个数组展开到新数组中。 123let words = [&quot;never&quot;, &quot;fully&quot;];console.log([&quot;will&quot;, ...words, &quot;understand&quot;]);// → [&quot;will&quot;, &quot;never&quot;, &quot;fully&quot;, &quot;understand&quot;] 4.14 Math对象Math是一个与数字有关的实用函数的集合。 Math对象用作容器用于对一组相关的功能进行分组。 最小值Math.min、最大值Math.max、平方根Math.sqrt π：Math.PI Math.random：0到1的随机数 Math.floor：向下舍入到最接近的整数 随机整数： 12console.log(Math.floor(Math.random() * 10));// → 2 Math.ceil：向上取整 Math.round：四舍五入到最接近的整数 Math.abs：取数字的绝对值 4.15 解构1234567function phi(table) &#123; return (table[3] * table[0] - table[2] * table[1]) / Math.sqrt((table[2] + table[3]) * (table[0] + table[1]) * (table[1] + table[3]) * (table[0] + table[2]));&#125; 上面函数用一个绑定指向数组，但在JavaScript中有一种简洁的方法可以对数组的元素进行绑定： 12345function phi([n00, n01, n10, n11]) &#123; return (n11 * n00 - n10 * n01) / Math.sqrt((n10 + n11) * (n00 + n01) * (n01 + n11) * (n00 + n10));&#125; 这也适用于let、var或const创建的绑定。如果绑定的值是一个数组，则可以使用中括号“查看”值，并绑定其内容。类似的技巧也适用于对象，但使用的是大括号而不是中括号。 123let &#123;name&#125; = &#123;name: &quot;Faraji&quot;, age: 23&#125;;console.log(name);// → Faraji 4.16 JSONJavaScript Object Notation 看起来类似JavaScript编写数组和对象的方式，但有一些限制。所有属性名称都必须用双括号括起来，并且只允许使用最简单的数据表达式——没有函数调用、绑定或涉及实际计算的任何内容。JSON中不允许注释。 JSON.stringify：获取JavaScript值并返回JSON编码的字符串 JSON.parse：取得字符串并将其转换为它编码的值 4.17 小结JavaScript中的大多数值都具有属性，null和undefined除外。对象倾向于使用名称作为其属性","categories":[],"tags":[]}],"categories":[],"tags":[]}