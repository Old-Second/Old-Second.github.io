{"meta":{"title":"OldSecond's Blog","subtitle":"","description":"","author":"OldSecond","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-10-19T16:23:50.000Z","updated":"2021-10-19T16:23:50.635Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"防抖和节流","slug":"防抖和节流","date":"2022-04-01T16:00:00.000Z","updated":"2022-04-03T08:27:13.642Z","comments":true,"path":"2022/04/02/防抖和节流/","link":"","permalink":"http://example.com/2022/04/02/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时。 简单总结就是 延时执行 最后一次触发。 用户多次频繁的触发某个事件，从第一次触发事件后开始计时，在未满足时间间隔时就进行了第二次触发，那么将第一次触发的事件清除 ，对第二次触发的事件重新开始计时；在未满足时间间隔时就进行了第三次触发，那么将第二次触发的事件清除，对第三次触发的事件重新开始计时，在满足时间间隔的一段时间内，用户未触发事件，则执行第三次触发的事件(即最后一次) ，以此类推。上述过程完成后，如果用户又一次触发了这个事件，重复上述过程 。 实现代码通过定时器将回调函数进行延时.如果在规定时间内继续回调,发现存在之前的定时器,则将该定时器清除,并重新设置定时器.这里有个细节,就是后面所有的回调函数都要能访问到之前设置的定时器 123456789101112131415161718192021var btn = document.getElementById(&#x27;input&#x27;)btn.addEventListener(&#x27;click&#x27;, debounce(submit))// btn.addEventListener(&#x27;click&#x27;, submit)function submit() &#123; console.log(this) console.log(123)&#125;function debounce(f) &#123; var timer = null return function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; f.call(this) &#125;, 1000) &#125;&#125; 注意点： 1.使后面所有的回调函数都能访问到之前设置的定时器 在外层定义变量timer,并在内层函数使用了这个变量；同时debounce函数会返回一个f函数，当返回的这个f函数调用时，debounce函数已经执行完毕，但在功能函数中任然可以访问定义在debounce函数中的局部变量timer，也就是从debounce函数外部能访问debounce函数内部的变量，这就形成了闭包。以使后面所有的回调函数，都能访问到之前设置的定时器。 2.最后一次调用函数，不会被清除。 在函数第一次被触发时，timer=null, 不会执行clearTimeout(timer)；在规定的时间间隔内，进行第二次调用，将会在第一次定时器的回调函数还未执行时，就将其取消(即清除)，对第二次触发进行重新计时，若在等待完规定的毫秒数后，没有新的触发，那么第二次的定时器回调函数正常执行。但在用户最后一次触发函数后，后续再也不会执行clearTimeout(timer)，所以最后一次定义的定时器的回调函数会正常执行。 3.不要改变f的原this指向 在setTimeout的回调中调用submit时， 要考虑到setTimeout是宏任务，在当前同步代码结束后，才会调用setTimeout的回调函数，会造成this丢失，所以应该在setTimeout回调内部去执行submit时，为submit绑定当前的this指向。由于setTimeout回调是箭头函数，所以setTimeout回调内部的this就是原本的this指向。 节流当持续触发事件时，在规定时间段内只能调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做。 两种实现方法定时器版先设置一个局部变量timer，初始化为null,第一次触发函数后，设置定时器的同时赋值给timer， 定时器任务完成期间的调用会被忽略不执行任何操作，直至定时器完成将变量timer置为null；再次调用时，再次定时器，设置定时器的同时赋值给timer， 定时器任务完成期间的调用会被忽略不执行任何操作，直至定时器完成将变量timer置为null；…。 12345678910111213141516171819202122function changeColor() &#123; let r = Math.floor(Math.random() * 255) let g = Math.floor(Math.random() * 255) let b = Math.floor(Math.random() * 255) document.body.style.background = `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`&#125;function throttle(f) &#123; var timer = null return function () &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; f.call(this) timer = null &#125;, 1000) &#125;&#125;window.addEventListener(&#x27;resize&#x27;, throttle(changeColor)) 特点: 当第一次触发事件时，不会立即执行函数，到了规定时间后才会执行。 之后连续频繁地触发事件，也是到了规定时间才会执行一次(因为定时器)。在等待经过时间间隔的期间，第2次、第3次的调用会被忽略，当等待过规定时间后，将执行第1次触发放入的回调；接着，第4次触发会被放入定时器的回调函数中，在等待经过时间间隔的期间，第5次的调用会被忽略，等待过规定时间后，将执行第4次触发放入的回调；接着，最后一次触发也就是第6次触发会被放入定时器的回调函数中，等待过规定时间后，将执行第6次触发放入的回调。 当最后一次停止触发后，由于定时器的延时，还会执行一次回调函数(那也是上一次成功成功触发执行的回调,而不是你最后一次触发产生的)。一句话总结就是延时回调,你能看到的回调都是上次成功触发产生的,而不是你此刻触发产生的。 时间戳版先设置一个last记录上一次触发的时间戳，在返回的函数内部设置一个变量now记录此刻调用的时间，判断now-last大于设置时间则执行函数，并将last设置为now。否则什么也不做。 12345678910111213141516171819function changeColor() &#123; let r = Math.floor(Math.random() * 255) let g = Math.floor(Math.random() * 255) let b = Math.floor(Math.random() * 255) document.body.style.background = `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`&#125;function throttle(f, delay) &#123; let last = 0 return function () &#123; let now = new Date() if (now - last &gt; delay) &#123; f() pre = now &#125; &#125;&#125;window.addEventListener(&#x27;resize&#x27;, throttle(changeColor, 1000)) 特点： 第一次会立即执行，之后连续频繁地触发事件，也是超过了规定时间才会执行下一次。最后一次触发事件，也不会执行(说明:如果你最后一次触发时间大于规定时间,这样就算不上连续频繁触发了). 第一次触发函数会立即执行，之后等待经过时间间隔的期间，第2次、第3次的调用会被忽略，当等待过规定时间后，将第4次触发函数立即执行；之后等待经过时间间隔的期间，第5次、第6次的调用会被忽略，当等待过规定时间后，将第7次触发函数立即执行；由于第8次调用在时间间隔内，所以不会执行。 这两者最大的区别:是时间戳版的函数触发是在规定时间开始的时候，而定时器版的函数触发是在规定时间结束的时候。","categories":[],"tags":[],"author":"OldSecond"},{"title":"原型（prototype）","slug":"原型","date":"2021-12-03T16:00:00.000Z","updated":"2021-12-03T20:55:03.728Z","comments":true,"path":"2021/12/04/原型/","link":"","permalink":"http://example.com/2021/12/04/%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"在声明了一个函数之后，会自动按照一定的规则创建一个对象，这个对象就叫做原型对象。这个函数中会有一个属性prototype，这个属性指向的就是这个函数对应的原型对象；原型对象中有一个属性constructor，这个属性指向的是这个函数。 使用构造函数创建对象1234function students() &#123;&#125;var stu = new students(); 此时，stu就是那个构造函数students创建出来的对象，这个stu对象中是没有prototype属性的，prototype属性只在构造函数students中有。 1234console.log(stu.prototype)//输出 undefinedconsole.log(stu.__proto__)//输出 &#123;constructor: ƒ&#125; 构造函数students中有prototype属性，指向的是students对应的原型对象；而stu是构造函数students创建出来的对象，不存在prototype属性，所以在调用prototype的时候的结果是undefined，但stu有一个__proto__属性，stu调用这个属性可以直接访问到构造函数students的原型对象（也就是说，stu的__proto__属性指向的是构造函数的原型对象） 从上面可以看到，创建stu对象虽然使用的是students构造函数，但是对象创建出来之后，这个stu对象其实已经与students构造函数没有任何关系了，stu对象的__proto__属性指向的是students构造函数的原型对象。 如果使用new students()创建多个对象stu1、stu2、stu3，则多个对象都会同时指向students构造函数的原型对象。 12console.log(stu1.__proto__ == stu2.__proto__);//输出 true 我们可以手动给这个原型对象添加属性和方法，那么stu1,stu2,stu3…这些对象就会共享这些在原型中添加的属性和方法。 12345students.prototype.name=&quot;张三&quot;;console.log(stu1.__proto__.name)//输出 张三console.log(stu2.__proto__.name)//输出 张三 如果我们访问stu中的一个属性name，如果在stu对象中找到，则直接返回。如果stu对象中没有找到，则直接去stu对象的__proto__属性指向的原型对象中查找，如果查找到则返回。如果原型中也没有找到，则继续向上在原型的原型中找。若直到找到了Object对象的原型Object.prototype(祖先原型)仍未找到，则返回undefined。 如果通过stu2对象添加了一个属性name，则对于stu2对象来说就屏蔽了原型中的属性name。 换句话说：在stu2中就没有办法访问到原型的属性name了。而通过stu对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 stu2.name = “李四”; 并不是修改了原型中的值，而是在stu2对象中给添加了一个属性name。 123456students.prototype.name = &quot;张三&quot;;stu2.name = &quot;李四&quot;;console.log(stu1.name)//输出 张三console.log(stu2.name)//输出 李四 与原型有关的几个方法prototype属性存在于构造函数中，指向了这个构造函数的原型对象。 constructor属性存在于原型对象中，指向了构造函数 1234function students() &#123;&#125;;console.log(students.prototype.constructor == students)//输出 true __proto__ 属性用构造方法创建一个新的对象之后，这个对象中默认会有一个属性__proto__, 这个属性就指向构造方法的原型对象。","categories":[],"tags":[],"author":"OldSecond"},{"title":"块级格式化上下文（Block Formatting Context，BFC）","slug":"块级格式化上下文","date":"2021-10-22T16:00:00.000Z","updated":"2021-11-01T15:47:22.581Z","comments":true,"path":"2021/10/23/块级格式化上下文/","link":"","permalink":"http://example.com/2021/10/23/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"一、什么是BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，BFC内部的元素布局与外部互不影响 二、形成BFC的条件根元素（&lt;html&gt;）浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group、inline-table)overflow 计算值(Computed)不为 visible 的块元素display 值为 flow-root 的元素contain 值为 layout、content 或 paint 的元素弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）网格元素（display 为 grid 或 inline-grid 元素的直接子元素）多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中 三、BFC布局规则1.内部的Box会在垂直方向，一个接一个地放置。2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。4.BFC的区域不会与float的元素重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算 四、BFC应用实例1. 自适应两栏布局1234567891011121314body &#123; width: 300px; position: relative;&#125;.aside &#123; width: 100px; height: 150px; float: left; background: #f66;&#125;.main &#123; height: 200px; background: #fcc;&#125; 1234&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第三条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float的元素重叠 可以通过通过使main生成BFC， 来实现自适应两栏布局。123.main &#123; overflow: hidden;&#125;当main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 2. 清除内部浮动1234567891011.father &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width: 100px; height: 100px; float: left;&#125; 123456&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发father生成BFC，那么father在计算高度时，father内部的浮动元素child也会参与计算。 123.father &#123; overflow: hidden;&#125; 效果如下： 3. 防止垂直 margin 重叠12345678p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 1234&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 1234567891011.wrap &#123; overflow: hidden;&#125;p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 123456&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 总结以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。","categories":[],"tags":[],"author":"OldSecond"},{"title":"","slug":"Eloquent JavaScript","date":"1970-01-01T00:00:00.000Z","updated":"2021-12-03T14:58:39.076Z","comments":true,"path":"1970/01/01/Eloquent JavaScript/","link":"","permalink":"http://example.com/1970/01/01/Eloquent%20JavaScript/","excerpt":"","text":"Eloquent JavaScript第1章 值、类型和运算符第2章 程序结构第3章 函数3.1 定义一个函数使用以关键字function开头的表达式创建函数。函数有一组参数和一个函数体，其中包含调用函数时要执行的语句。以这种方式创建的函数的函数体必须用大括号括起来，即使它只包含一个语句。 函数的返回值可以有，可以没有，没有则默认返回 undefined。函数可以制造副作用，也可以返回值 3.2 绑定和作用域全局绑定：对于在任何函数或块之外定义的绑定，作用域是整个程序可以在任何地方引用此类绑定。 局部绑定：为函数参数创建的绑定或在函数内声明的绑定只能在此函数中引用。 let和const声明的绑定是在声明它们的块中局部可见的，如果在循环中创建上面两种绑定，循环之前和之后代码都不能“看到”它。var创建的绑定在出现它们的整个函数中是可见的，如果它们不在一个函数中，则它们在全局作用域中可见。 每个作用域可以”查看“包围它的作用域，因此x在下面示例中的块内部是可见的。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); //→60&#125;//y在此处不可见console.log(x + z);//→40 异常情况：多个绑定具有相同的名称，这时代码只能看到最里面的一个。如下示例，在halve函数内部的代码引用n时，它只能看到自己n，而不是全局的n。 123456789const halve = function(n) &#123; return n / 2;&#125;;let n = 10;console.log(halve(100));//→50console.log(n);//→10 js不仅区分全局绑定和局部绑定，还可以在其他块和函数内创建块和函数，从而产生多个度的局部。 词法作用域：块内可见的绑定集由程序文本中此块的位置确定。每个局部作用域可以查看包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 3.3 作为值的函数函数值能执行其他值能执行的所有操作，可以在任意表达式找那个使用它，而不仅仅是调用它。可以将函数值存储在新绑定中，将其作为参数传递给函数。 保存函数的绑定仍然是常规绑定，如果不是常量，就可以赋予一个新值 3.4 声明表示法123function square(x) &#123; return x * x;&#125; 这是一个函数声明，并且在函数后不需要分号。 12345console.log(&quot;The future says:&quot;, future());function future() &#123; return &quot;You&#x27;ll never have flying cars&quot;;&#125; 即使函数是在使用它的代码下定义的，也可以正常工作。函数声明不是常规的从上到下控制流程一部分。它们在概念上被移动到它们的作用域的顶部，可以由此作用域中的所有代码使用。 3.5 箭头函数函数的第三种表示法使用(=&gt;)代替function关键字 1234567const power = (base, exponent) =&gt; &#123; let result = 1; for (let count = 0; count &lt; exponent; count++) &#123; result *= base; &#125; return result;&#125;; 如果只有一个参数名称，则可以省略参数列表周围的括号。如果函数体是单个表达式而不是大括号中的块，则该函数将返回这个表达式。示例如下： 12const square1 = (x) =&gt; &#123; return x * x; &#125;;const square2 = x =&gt; x * x; 当箭头函数没有参数时，其参数列表只是一组空括号。 123const horn = () =&gt; &#123; console.log(&quot;Toot&quot;);&#125;; 3.6 调用栈在函数返回时必须跳回调用它的位置，所有计算机必须记住调用发生的上下文。计算机存储此上下文的位置是调用栈。每次调用函数时，当前上下文都存储在此栈的顶部。当函数返回时，它会从栈中删除顶层上下文冰使用次上下文继续执行 存储此栈需要计算机内存中的空间。当栈变得太大时，计算机将失败并显示“栈空间不足”或“递归过多”等消息。示例如下： 12345678function chicken() &#123; return egg();&#125;function egg() &#123; return chicken();&#125;console.log(chicken() + &quot; came first.&quot;);// → ?? 3.7 可选参数123function square(x) &#123; return x * x; &#125;console.log(square(4, true, &quot;hedgehog&quot;));// → 16 上面只用了一个参数定义了square，但当我们用三个函数调用它时，JavaScript会忽略额外的参数并计算第一个参数的平方。 如果传递太多参数，则会忽略额外的参数，如果传递的参数太少，则缺少的参数将赋值为undefined。 缺点是可能会将错误数量的参数传递给函数。好处是可用于允许使用不同数量的参数调用的函数。例如：用minus函数模仿”-“运算符 123456789function minus(a, b) &#123; if (b === undefined) return -a; else return a - b;&#125;console.log(minus(10));// → -10console.log(minus(10, 5));// → 5 如果在参数后写一个=运算符，后跟一个表达式，那么将在未给出某参数时用此表达式的值替换该参数。例如： 123456789101112function power(base, exponent = 2) &#123; let result = 1; for (let count = 0; count &lt; exponent; count++) &#123; result *= base; &#125; return result;&#125;console.log(power(4));// → 16console.log(power(2, 6));// → 64 3.8 闭包3.8.1 概念引用其周围局部作用域的绑定的一个函数称为一个闭包 有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。 第一，闭包是一个函数，而且存在于另一个函数当中 第二，闭包可以访问到父级函数的变量，且该变量不会销毁 1234567891011function person()&#123; var name = &#x27;有鱼&#x27;; function cat()&#123; console.log(name); &#125; return cat;&#125;var per = person();// per的值就是return后的结果，即cat函数per();// 有鱼 per()就相当于cat()per();// 有鱼 同上，而且变量name没有销毁，一直存在内存中，供函数cat调用per();// 有鱼 3.8.2 原理闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。 例如： 123456var age = 18;function cat()&#123; age++; console.log(age);// cat函数内输出age，该作用域没有，则向外层寻找，结果找到了，输出[19];&#125;cat();//19 如果再次调用，age的值会一直增加。 123cat();//20cat();//21cat();//22 如果其他函数需要用到age的值，那么就会受到影响，且全局变量容易被修改，所以要把变量封装到函数内，让它成为局部变量 12345678910function person()&#123; var age = 18; function cat()&#123; age++; console.log(age); &#125; return cat;&#125;person();// 19person();// 19 若如上例，则每次调用函数，age会重新赋值为18，所以cat的值一直为19，因此做如下调整： 1234var per = person();//per相当于函数catper();// 19 即cat() 这样每次调用不在经过age的初始值，这样就可以一直增加了per();// 20per();// 21 3.8.3 作用作用1：隐藏变量，避免全局污染 作用2：可以读取函数内部的变量 同时闭包使用不当，优点就变成了缺点： 缺点1：导致变量不会被垃圾回收机制回收，造成内存消耗 缺点2：不恰当的使用闭包可能会造成内存泄漏的问题 这里简单说一下，为什么使用闭包时变量不会被垃圾回收机制收销毁呢，这里需要了解一下JS垃圾回收机制； JS规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可节省内存； 使用闭包时，按照作用域链的特点，闭包（函数）外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存销毁。 3.9 递归调用自身的函数称为递归函数 12345678910function power(base, exponent) &#123; if (exponent == 0) &#123; return 1; &#125; else &#123; return base * power(base, exponent - 1); &#125;&#125;console.log(power(2, 3));// → 8 在这个例子中，使用递归的速度比使用循环的速度慢，但递归并不总是替代循环的低效方法，使用递归比使用循环更容易解决一些问题。 题：从1开始，重复加5或乘3，可以生成一个由无数的数字组合成的集合。对于给定的一个数字，找到产生这个数字的一系列加法和乘法。 以下为一个递归的方案： 12345678910111213141516function findSolution(target) &#123; function find(current, history) &#123; if (current == target) &#123; return history; &#125; else if (current &gt; target) &#123; return null; &#125; else &#123; return find(current + 5, `($&#123;history&#125; + 5)`) || find(current * 3, `($&#123;history&#125; * 3)`); &#125; &#125; return find(1, &quot;1&quot;);&#125;console.log(findSolution(24));// → (((1 * 3) + 5) * 3) 3.10 函数的增长方式什么时候应该添加一个函数： ①多次编写类似的代码时，可以把重复的功能提取出来放入一个函数中 ②需要一下尚未编写的功能时并且它应该有自己的函数时，将从命名函数开始，然后编写它的函数体。在实际定义函数之前，可能已经开始编写使用此函数的代码 为函数命名：驼峰命名法 3.11 函数和副作用函数可以粗略分为为了副作用而调用的函数和为了其返回值而调用的函数。 纯函数是一种特定的产生值的函数，它不仅没有副作用，而且不依赖于其他代码的副作用。 3.12 小结创建函数的三种方法： 1234// 定义f以保存函数值const f = function(a) &#123; console.log(a + 2);&#125;; 1234// 将g声明为函数function g(a, b) &#123; return a * b * 3.5;&#125; 12// 箭头函数let h = a =&gt; a % 3; 第4章 数据结构：对象和数组4.1 松鼠人4.2 数据集数组：专门用于存储值序列的数据类型，写法是将一连串的值写在方括号中，值中间使用逗号分隔。 1234567let listOfNumbers = [2, 3, 5, 7, 11];console.log(listOfNumbers[2]);// → 5console.log(listOfNumbers[0]);// → 2console.log(listOfNumbers[2 - 1]);// → 3 获取数组内部元素也用方括号表示，写法是表达式后紧跟一对方括号，并在方括号中填写表达式，将会在左侧表达式里查找方括号中给定的索引所对应 的值，并返回结果。数组的第一个索引是0，而不是1。 4.3 属性如myString.length（获取字符串的长度）和Math.max（取最大值函数）。这是访问某个值的属性的表达式。 几乎所有JavaScript值都具有属性，但null和undefined除外，尝试访问这两种值的属性，则会出现错误。 12null.length;// → TypeError: null has no properties 访问属性的两种主要方法是使用句点和方括号。 value.x和value[x]都访问值上的属性，但不一定是相同的属性。使用句点时，点后面的单词是属性的文字名称。而使用方括号时，将计算括号中的表达式来获取属性名称。点表示法仅适用于其名称看起来像有效绑定名称的情况。例如：数组中的元素存储为数组的属性，使用数字作为属性名称，因此不能用点表示法获取。 4.4 方法字符串和数组对象都包含许多保存函数值的属性。 toUpperCase：将所有字母转化为大写；toLowerCase：将所有字母转化为小写。 push将值添加到数组的末尾，pop删除数组中最后一个值并返回。 4.5 对象类型对象的值是属性的任意集合。创建对象的一种方法是使用大括号作为表达式。大括号内有以逗号分隔的属性列表。每个属性都有一个名称，后跟冒号和值。当属性名不是有效绑定名称或有效数字时，必须用引号括起来。 可以用=为属性表达式赋值，若已存在则替换属性的值，不存在则创建新属性。 delete将从对象中删除命名属性。二元运算符in会告诉你此对象是否具有该名称的属性。将属性设置为undefined时，对象仍然存在此属性；当删除它时，对象将不存在此属性且in将返回false 12345678910let anObject = &#123;left: 1, right: 2&#125;;console.log(anObject.left);// → 1delete anObject.left;console.log(anObject.left);// → undefinedconsole.log(&quot;left&quot; in anObject);// → falseconsole.log(&quot;right&quot; in anObject);// → true 找出对象具有哪些属性，可使用Object.keys函数 12console.log(Object.keys(&#123;x: 0, y: 0, z: 2&#125;));// → [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] Object.assign函数可以从一个对象把所有属性复制到另一个对象。 1234let objectA = &#123;a: 1, b: 2&#125;;Object.assign(objectA, &#123;b: 3, c: 4&#125;);console.log(objectA);// → &#123;a: 1, b: 3, c: 4&#125; 因此，数组只是一种专门用于存储事物序列的对象。 4.6 可变性对象可以通过修改其属性从而使单个对象值在不同的时候具有不同的内容。 同一对象的两次引用与包含两个相同属性的两个不同对象之间存在差异。 123456789101112let journal = [ &#123;events: [&quot;work&quot;, &quot;touched tree&quot;, &quot;pizza&quot;, &quot;running&quot;, &quot;television&quot;], squirrel: false&#125;, &#123;events: [&quot;work&quot;, &quot;ice cream&quot;, &quot;cauliflower&quot;, &quot;lasagna&quot;, &quot;touched tree&quot;, &quot;brushed teeth&quot;], squirrel: false&#125;, &#123;events: [&quot;weekend&quot;, &quot;cycling&quot;, &quot;break&quot;, &quot;peanuts&quot;, &quot;beer&quot;], squirrel: true&#125;, /* and so on... */]; object1和object2绑定抓住了同一个对象，也就是说他们拥有相同的标识。而绑定object3虽然包含和object1相同的属性，但却单独存在。 当使用==比较对象时，会按照标识进行比较：仅当两个对象都是完全相同的值时才会得到true。即使两个不同的对象具有相同的属性，也将返回false。 4.7 松鼠人的日志4.8 计算相关性4.9 数组循环4.10 最终分析4.11 其他数组方法push和pop在数组的末尾添加和删除元素。 123456789let sequence = [1, 2, 3];sequence.push(4);sequence.push(5);console.log(sequence);// → [1, 2, 3, 4, 5]console.log(sequence.pop());// → 5console.log(sequence);// → [1, 2, 3, 4] unshift和shift在数组的开头添加和删除元素。 12345678910let todoList = [];function remember(task) &#123; todoList.push(task);&#125;function getTask() &#123; return todoList.shift();&#125;function rememberUrgently(task) &#123; todoList.unshift(task);&#125; indexOf从开始到结束搜索数组并返回找到给定值的所有，未找到则返回-1。lastIndexOf从末尾而不是从头开始搜索。indexOf和lastIndexOf都有一个可选的第二参数，表示从哪里开始搜索。 1234console.log([1, 2, 3, 2, 1].indexOf(2));// → 1console.log([1, 2, 3, 2, 1].lastIndexOf(2));// → 3 slice接收起始和结束索引并返回一个只包含它们之间元素的数组（前闭后开）。当没有给出结束索引时，slice将获取起始索引之后的所有元素。 1234console.log([0, 1, 2, 3, 4].slice(2, 4));// → [2, 3]console.log([0, 1, 2, 3, 4].slice(2));// → [2, 3, 4] concat方法可用于将数组黏合在一起以创建新数组。如果给concat传递一个不是数组的参数，那么此值将被添加到新数组中。 123456function remove(array, index) &#123; return array.slice(0, index) .concat(array.slice(index + 1));&#125;console.log(remove([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], 2));// → [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;] 4.12 字符串及其属性字符串、数字、布尔类型的值不是对象。 字符串的slice和indexOf属性与同名的数组方法类似。 1234console.log(&quot;coconuts&quot;.slice(4, 7));// → nutconsole.log(&quot;coconut&quot;.indexOf(&quot;u&quot;));// → 5 两者区别之一是字符串的indexOf方法可以搜索包含多个字符的字符串，而同名的数组方法只能查找单个元素。 12console.log(&quot;one two three&quot;.indexOf(&quot;ee&quot;));// → 11 trim方法从字符串的开头和结尾删除空格（空格、换行符、制表符和类似字符）。 12console.log(&quot; okay \\n &quot;.trim());// → okay padStrart将所需的长度和填充字符作为参数。 12console.log(String(6).padStart(3, &quot;0&quot;));// → 006 使用split在每次出现另一个字符串时拆分字符串，并使用join再次把它们拼接起来。 123456let sentence = &quot;Secretarybirds specialize in stomping&quot;;let words = sentence.split(&quot; &quot;);console.log(words);// → [&quot;Secretarybirds&quot;, &quot;specialize&quot;, &quot;in&quot;, &quot;stomping&quot;]console.log(words.join(&quot;. &quot;));// → Secretarybirds. specialize. in. stomping repeat方法重复一个字符串，这会创建一个把原始字符串的多个副本黏合在一起的新字符串。 12console.log(&quot;LA&quot;.repeat(3));// → LALALA length，访问字符串中的单个字符看起来像访问数组元素。 12345let string = &quot;abc&quot;;console.log(string.length);// → 3console.log(string[1]);// → b 4.13 剩余参数要编写能接受任意数量参数的函数，需要在函数的最后一个参数之前放三个点。 123456789function max(...numbers) &#123; let result = -Infinity; for (let number of numbers) &#123; if (number &gt; result) result = number; &#125; return result;&#125;console.log(max(4, 1, 9, -2));// → 9 以...为前缀的最后一个命名参数，将成为一个由剩余参数组成的真数组，其中从0（包括）到numbers.length（排除）的元素由传递给函数的实际参数提供。 调用此类函数时，剩余参数被绑定到包含所有后续参数的数组中。如果剩余参数之前还有其他参数，则那些参数的值不是此数组的一部分。 可使用类似的三点表示法来调用带有参数数组的函数。 123let numbers = [5, 1, 7];console.log(max(...numbers));// → 7 这会将数组的元素作为单独的参数传递。函数调用可以同时包含像这样的数组以及其他参数，如max(9,…numbers,2). 方括号数组表示法同样允许利用三点运算符将另一个数组展开到新数组中。 123let words = [&quot;never&quot;, &quot;fully&quot;];console.log([&quot;will&quot;, ...words, &quot;understand&quot;]);// → [&quot;will&quot;, &quot;never&quot;, &quot;fully&quot;, &quot;understand&quot;] 4.14 Math对象Math是一个与数字有关的实用函数的集合。 Math对象用作容器用于对一组相关的功能进行分组。 最小值Math.min、最大值Math.max、平方根Math.sqrt π：Math.PI Math.random：0到1的随机数 Math.floor：向下舍入到最接近的整数 随机整数： 12console.log(Math.floor(Math.random() * 10));// → 2 Math.ceil：向上取整 Math.round：四舍五入到最接近的整数 Math.abs：取数字的绝对值 4.15 解构1234567function phi(table) &#123; return (table[3] * table[0] - table[2] * table[1]) / Math.sqrt((table[2] + table[3]) * (table[0] + table[1]) * (table[1] + table[3]) * (table[0] + table[2]));&#125; 上面函数用一个绑定指向数组，但在JavaScript中有一种简洁的方法可以对数组的元素进行绑定： 12345function phi([n00, n01, n10, n11]) &#123; return (n11 * n00 - n10 * n01) / Math.sqrt((n10 + n11) * (n00 + n01) * (n01 + n11) * (n00 + n10));&#125; 这也适用于let、var或const创建的绑定。如果绑定的值是一个数组，则可以使用中括号“查看”值，并绑定其内容。类似的技巧也适用于对象，但使用的是大括号而不是中括号。 123let &#123;name&#125; = &#123;name: &quot;Faraji&quot;, age: 23&#125;;console.log(name);// → Faraji 4.16 JSONJavaScript Object Notation 看起来类似JavaScript编写数组和对象的方式，但有一些限制。所有属性名称都必须用双括号括起来，并且只允许使用最简单的数据表达式——没有函数调用、绑定或涉及实际计算的任何内容。JSON中不允许注释。 JSON.stringify：获取JavaScript值并返回JSON编码的字符串 JSON.parse：取得字符串并将其转换为它编码的值 4.17 小结JavaScript中的大多数值都具有属性，null和undefined除外。对象倾向于使用名称作为其属性 第5章 高阶函数5.1 抽象化5.2 提取重复的内容将函数作为一个函数值传递 12345678910function repeat(n, action) &#123; for (let i = 0; i &lt; n; i++) &#123; action(i); &#125;&#125;repeat(3, console.log);// → 0// → 1// → 2 通常在原地创建传入的函数更方便 123456let labels = [];repeat(5, i =&gt; &#123; labels.push(`Unit $&#123;i + 1&#125;`);&#125;);console.log(labels);// → [&quot;Unit 1&quot;, &quot;Unit 2&quot;, &quot;Unit 3&quot;, &quot;Unit 4&quot;, &quot;Unit 5&quot;] 5.3 高阶函数高阶函数：接受一个函数作为参数，或者返回一个函数的函数。 可以使用高阶函数创建新的函数： 1234function greaterThan(n) &#123; return m =&gt; m &gt; n;&#125;console.log(greaterThan(10)(11)); 可以用高阶函数改变其他函数： 1234567891011function noisy(f) &#123; return (...args) =&gt; &#123; console.log(&quot;calling with&quot;, args); let result = f(...args); console.log(&quot;called with&quot;, args, &quot;, returned&quot;, result); return result; &#125;;&#125;noisy(Math.min)(3, 2, 1);// → calling with [3, 2, 1]// → called with [3, 2, 1] , returned 1 用高阶函数提供新的控制流类型： 1234567891011function unless(test, then) &#123; if (!test) then();&#125;repeat(3, n =&gt; &#123; unless(n % 2 == 1, () =&gt; &#123; console.log(n, &quot;is even&quot;); &#125;);&#125;);// → 0 is even// → 2 is even 数组内置的方法forEach，提供了类似于把for/of循环作为高阶函数的功能： 123[&quot;A&quot;, &quot;B&quot;].forEach(l =&gt; console.log(l));// → A// → B 5.4 语言字符集数据集5.5 过滤数组以下函数把数组中未通过测试的元素过滤掉： 123456789101112function filter(array, test) &#123; let passed = []; for (let element of array) &#123; if (test(element)) &#123; passed.push(element); &#125; &#125; return passed;&#125;console.log(filter(SCRIPTS, script =&gt; script.living));// → [&#123;name: &quot;Adlam&quot;, …&#125;, …] 这个函数是纯函数，不会修改给定的数组。 与forEach一样，filter也是一种标准的数组方法，本示例仅用于显示其内部执行的操作，我们使用如下的写法来代替上面的写法： 12console.log(SCRIPTS.filter(s =&gt; s.direction == &quot;ttb&quot;));// → [&#123;name: &quot;Mongolian&quot;, …&#125;, …] 5.6 用map转换map方法通过将函数应用于其所有元素并根据返回的值构建新数组来转换数组。新数组的长度将与输入数组相同，但其内容将由函数映射为新形式。 1234567891011function map(array, transform) &#123; let mapped = []; for (let element of array) &#123; mapped.push(transform(element)); &#125; return mapped;&#125;let rtlScripts = SCRIPTS.filter(s =&gt; s.direction == &quot;rtl&quot;);console.log(map(rtlScripts, s =&gt; s.name));// → [&quot;Adlam&quot;, &quot;Arabic&quot;, &quot;Imperial Aramaic&quot;, …] 5.7 用reduce汇总与数组有关的另一个常见问题是从它们计算单个值。例子是对一组数字求和，找到具有最多字符的语言字符集。 12345678910function reduce(array, combine, start) &#123; let current = start; for (let element of array) &#123; current = combine(current, element); &#125; return current;&#125;console.log(reduce([1, 2, 3, 4], (a, b) =&gt; a + b, 0));// → 10 如果数组包含至少一个元素，可不使用start参数。此方法将数组的第一个元素作为其起始值，并从第二个元素开始减少。 12console.log([1, 2, 3, 4].reduce((a, b) =&gt; a + b));// → 10 使用reduce来查找具有最多字符的语言字符集： 12345678910function characterCount(script) &#123; return script.ranges.reduce((count, [from, to]) =&gt; &#123; return count + (to - from); &#125;, 0);&#125;console.log(SCRIPTS.reduce((a, b) =&gt; &#123; return characterCount(a) &lt; characterCount(b) ? b : a;&#125;));// → &#123;name: &quot;Han&quot;, …&#125; characterCount函数通过对分配给语言字符集的各个范围大小进行累加来减少这些范围。在reduce函数参数列表中使用了解构功能。第二次调用reduce通过重复比较两个语言字符集并返回较大的语言字符集来使用它查找规模最大的语言字符集。 5.8 组合性5.9 字符串和字符代码每个语言字符集都有一个与之关联的字符代码范围数组。所以给定一个字符代码，我们就可以使用这样的函数来查找相应的语言字符集： 12345678910111213function characterScript(code) &#123; for (let script of SCRIPTS) &#123; if (script.ranges.some(([from, to]) =&gt; &#123; return code &gt;= from &amp;&amp; code &lt; to; &#125;)) &#123; return script; &#125; &#125; return null;&#125;console.log(characterScript(121));// → &#123;name: &quot;Latin&quot;, …&#125; some方法也是一个高阶函数，它需要一个测试函数，并告诉你数组中是否有任何元素输入测试函数后返回true。 UTF-16使用单个16位代码单元来描述最常见的字符，但使用两个这样的单元来表示其他字符。 12345678910// Two emoji characters, horse and shoelet horseShoe = &quot;🐴👟&quot;;console.log(horseShoe.length);// → 4console.log(horseShoe[0]);// → (Invalid half-character)console.log(horseShoe.charCodeAt(0));// → 55357 (Code of the half-character)console.log(horseShoe.codePointAt(0));// → 128052 (Actual code for horse emoji) charCodeAt方法为你提供一个代码单元，而不是一个完整的字符。codePointAt方法提供了一个完整的Unicode字符，但传递给codePointAt的参数仍然是代码单元序列的索引。 当使用for/of循环遍历一个字符串时，提供给你的是真正的字符而不是代码单元。 123456let roseDragon = &quot;🌹🐉&quot;;for (let char of roseDragon) &#123; console.log(char);&#125;// → 🌹// → 🐉 5.10 文本识别5.11 小结数组提供了许多有用的高阶方法。可以使用forEach循环遍历数组中的元素。 filter方法返回一个新数组，其中只包含符合谓语函数条件的元素。将每个元素放入函数来转换数组是通过map完成的。可以使用reduce将数组中的所有元素组合为单个值。some方法测试任何元素是否与给定的谓语函数匹配。findIndex查找与谓语匹配的第一个元素的位置。 第6章","categories":[],"tags":[]}],"categories":[],"tags":[]}